import { NextRequest, NextResponse } from "next/server";
import { getJson } from "serpapi";
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";

// Header categories mapping to Turkish search terms
const headerCategories = {
  fashion: [
    "moda giyim indirim",
    "kadƒ±n erkek giyim kampanya",
    "elbise pantolon g√∂mlek indirim",
    "ayakkabƒ± √ßanta aksesuar fƒ±rsat",
    "jean ti≈ü√∂rt kazak outlet",
  ],
  beauty: [
    "kozmetik g√ºzellik indirim",
    "cilt bakƒ±m √ºr√ºnleri kampanya",
    "parf√ºm makyaj indirim",
    "≈üampuan sa√ß bakƒ±m fƒ±rsat",
    "g√ºzellik √ºr√ºnleri outlet",
  ],
  sports: [
    "spor malzemeleri indirim",
    "spor ayakkabƒ± giyim kampanya",
    "fitness ekipmanlarƒ± fƒ±rsat",
    "spor √ßantasƒ± termos outlet",
    "atletik √ºr√ºnler indirim",
  ],
  electronics: [
    "elektronik indirim",
    "akƒ±llƒ± saat kulaklƒ±k kampanya",
    "telefon tablet bilgisayar fƒ±rsat",
    "elektronik aksesuar outlet",
    "teknoloji √ºr√ºnleri indirim",
  ],
  pets: [
    "evcil hayvan √ºr√ºnleri indirim",
    "k√∂pek kedi mamasƒ± kampanya",
    "pet aksesuar oyuncak fƒ±rsat",
    "hayvan bakƒ±m √ºr√ºnleri outlet",
    "evcil hayvan malzemeleri indirim",
  ],
  vitamins: [
    "vitamin takviye indirim",
    "saƒülƒ±k √ºr√ºnleri kampanya",
    "vitamin mineral fƒ±rsat",
    "beslenme takviyeleri outlet",
    "saƒülƒ±k vitamin indirim",
  ],
};

// Flatten all category queries into one array for discount search
const discountQueries = Object.values(headerCategories).flat();

// Function to check if product belongs to defined header categories
function isProductInHeaderCategories(product: any): boolean {
  const title = (product.title || "").toLowerCase();
  const description = (product.snippet || "").toLowerCase();
  const combined = title + " " + description;

  // Define keywords for each header category
  const categoryKeywords = {
    fashion: [
      "giyim",
      "elbise",
      "pantolon",
      "g√∂mlek",
      "ti≈ü√∂rt",
      "kazak",
      "mont",
      "ceket",
      "ayakkabƒ±",
      "√ßanta",
      "aksesuar",
      "jean",
      "etek",
      "bluz",
      "≈üort",
      "mayo",
      "moda",
      "fashion",
      "dress",
      "shirt",
      "pants",
      "shoes",
      "bag",
      "clothing",
      "kƒ±yafet",
      "terlik",
      "bot",
      "sandalet",
      "spor ayakkabƒ±",
      "sneaker",
    ],
    beauty: [
      "kozmetik",
      "g√ºzellik",
      "makyaj",
      "parf√ºm",
      "krem",
      "≈üampuan",
      "sa√ß",
      "cilt",
      "bakƒ±m",
      "beauty",
      "cosmetic",
      "makeup",
      "perfume",
      "skincare",
      "oje",
      "ruj",
      "maskara",
      "fond√∂ten",
      "pudra",
      "g√∂z kalemi",
      "dudak",
    ],
    sports: [
      "spor",
      "fitness",
      "antrenman",
      "ko≈üu",
      "y√ºzme",
      "futbol",
      "basketbol",
      "tenis",
      "golf",
      "yoga",
      "pilates",
      "spor malzemesi",
      "sport",
      "athletic",
      "gym",
      "exercise",
      "workout",
      "running",
      "swimming",
      "football",
      "basketball",
    ],
    electronics: [
      "elektronik",
      "telefon",
      "bilgisayar",
      "tablet",
      "kulaklƒ±k",
      "saat",
      "akƒ±llƒ±",
      "teknoloji",
      "electronic",
      "phone",
      "computer",
      "headphone",
      "smart",
      "technology",
      "laptop",
      "mouse",
      "keyboard",
      "charger",
      "cable",
    ],
    pets: [
      "evcil",
      "hayvan",
      "k√∂pek",
      "kedi",
      "mama",
      "pet",
      "animal",
      "dog",
      "cat",
      "food",
      "oyuncak",
      "tasma",
      "kafes",
      "kum",
      "bakƒ±m",
      "veteriner",
      "ku≈ü",
    ],
    vitamins: [
      "vitamin",
      "takviye",
      "saƒülƒ±k",
      "beslenme",
      "mineral",
      "protein",
      "health",
      "supplement",
      "nutrition",
      "omega",
      "probiyotik",
      "kolajen",
      "magnezyum",
      "demir",
      "√ßinko",
      "kalsiyum",
      "d3",
      "b12",
      "c vitamini",
    ],
  };

  // Check if product matches any header category
  return Object.values(categoryKeywords).some((keywords) =>
    keywords.some((keyword) => combined.includes(keyword))
  );
}

interface ShoppingProduct {
  id: string;
  title: string;
  originalTitle?: string;
  price: number;
  originalPrice?: number | null;
  currency: string;
  image: string;
  description: string;
  originalDescription?: string;
  link?: string;
  googleShoppingLink?: string;
  source: string;
  rating: number;
  reviews: number;
  delivery: string;
}

// Simple in-memory cache for discount products
let discountCache: {
  data: ShoppingProduct[];
  timestamp: number;
  ttl: number;
} | null = null;

// Cache duration: 10 minutes for discounts
const DISCOUNT_CACHE_TTL = 10 * 60 * 1000;

export async function GET(request: NextRequest) {
  try {
    console.log("üîç Starting discount products search...");

    // Check cache first
    const now = Date.now();
    if (discountCache && now - discountCache.timestamp < discountCache.ttl) {
      console.log("‚úÖ Returning cached discount products");
      return NextResponse.json({
        products: discountCache.data,
        total: discountCache.data.length,
        message: `${discountCache.data.length} ŸÖÿ≠ÿµŸàŸÑ ÿ™ÿÆŸÅ€åŸÅ‚ÄåÿØÿßÿ± ÿßÿ≤ ⁄©ÿ¥ €åÿßŸÅÿ™ ÿ¥ÿØ`,
        cached: true,
      });
    }

    // Check if API keys are available
    if (!process.env.SERPAPI_KEY) {
      console.error("‚ùå SERPAPI_KEY is not configured");
      return NextResponse.json(
        { error: "Search service is not configured" },
        { status: 500 }
      );
    }

    let allProducts: ShoppingProduct[] = [];

    // Add randomization for diverse results each time
    // Shuffle the queries array to get different results on each request
    const shuffledQueries = [...discountQueries].sort(
      () => Math.random() - 0.5
    );

    // Add random variation words for more diverse results
    const randomVariations = [
      "en uygun",
      "√∂zel fiyat",
      "b√ºy√ºk indirim",
      "fƒ±rsat",
      "kampanya",
      "ucuz",
      "avantajlƒ±",
      "ekonomik",
      "uygun",
      "son fiyat",
    ];

    // ÿßŸÑÿ®ÿ≠ÿ´ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±ÿßÿ™ ŸÖÿ™ÿπÿØÿØÿ© ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖŸÜÿ™ÿ¨ÿßÿ™ ŸÖÿ™ŸÜŸàÿπÿ©
    // Reduced from 3 to 2 parallel requests for better performance
    const maxQueries = 2;
    const selectedQueries = shuffledQueries.slice(0, maxQueries);

    // Use Promise.all for parallel requests instead of sequential
    const searchPromises = selectedQueries.map(async (baseQuery, i) => {
      let query = baseQuery;

      // Add random variation 40% of the time
      if (Math.random() > 0.6) {
        const randomWord =
          randomVariations[Math.floor(Math.random() * randomVariations.length)];
        query = `${query} ${randomWord}`;
        console.log(`üé≤ Added variation: "${randomWord}" to query`);
      }
      console.log(`üîç Searching with query ${i + 1}: "${query}"`);

      try {
        const serpApiParams = {
          engine: "google_shopping",
          q: query,
          gl: "tr", // ÿ™ÿ±ŸÉŸäÿß
          hl: "tr", // ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿ™ÿ±ŸÉŸäÿ©
          location: "Turkey",
          num: 20, // ÿπÿØÿØ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ŸÑŸÉŸÑ ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ±
          device: "desktop",
          api_key: process.env.SERPAPI_KEY,
        };

        const shoppingResults = await getJson(serpApiParams);

        if (
          shoppingResults.shopping_results &&
          shoppingResults.shopping_results.length > 0
        ) {
          console.log(
            `‚úÖ Found ${shoppingResults.shopping_results.length} products for query: "${query}"`
          );

          // Filter products to only include header categories
          const filteredProducts = shoppingResults.shopping_results.filter(
            isProductInHeaderCategories
          );

          console.log(
            `üìÇ Filtered to ${filteredProducts.length} products from header categories`
          );

          // ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ - optimized processing with reduced AI calls
          const processedProducts = filteredProducts
            .slice(0, 15)
            .map((product: any, index: number) => {
              // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿ™ÿÆŸÅŸäÿ∂ (ÿ≥ÿπÿ± ÿ£ÿµŸÑŸä ÿ£ÿπŸÑŸâ ŸÖŸÜ ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ≠ÿßŸÑŸä)
              let hasDiscount = false;
              let originalPrice = null;
              let currentPrice = 0;

              // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿ£ÿ≥ÿπÿßÿ± ŸÖÿπ validation ŸÖŸÜÿ∑ŸÇ€å
              console.log(`üîç Product ${index + 1}: ${product.title}`);
              console.log(`üí∞ Raw price data:`, {
                extracted_price: product.extracted_price,
                extracted_original_price: product.extracted_original_price,
                price: product.price,
                price_range: product.price_range,
              });

              // ÿ™ŸÑÿßÿ¥ ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ŸÇ€åŸÖÿ™ ÿßÿ≤ ŸÅ€åŸÑÿØŸáÿß€å ŸÖÿÆÿ™ŸÑŸÅ
              if (product.extracted_price && product.extracted_price >= 20) {
                currentPrice = product.extracted_price;
                console.log(`‚úÖ Using extracted_price: ${currentPrice}`);
                if (
                  product.extracted_original_price &&
                  product.extracted_original_price > currentPrice
                ) {
                  originalPrice = product.extracted_original_price;
                  hasDiscount = true;
                  console.log(`‚úÖ Found original price: ${originalPrice}`);
                }
              } else if (product.price && typeof product.price === "string") {
                // ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ÿπÿ± ŸÖŸÜ ÿßŸÑŸÜÿµ
                const priceMatch = product.price.match(/[\d,.]+(\.?\d+)?/);
                if (priceMatch) {
                  const parsedPrice = parseFloat(
                    priceMatch[0].replace(",", "")
                  );
                  if (parsedPrice >= 20) {
                    currentPrice = parsedPrice;
                    console.log(`‚úÖ Using parsed price: ${currentPrice}`);
                  } else {
                    console.log(`‚ùå Parsed price too low: ${parsedPrice}`);
                  }
                }
              } else {
                console.log(`‚ùå No valid price found in raw data`);
              }

              // ÿß⁄Øÿ± ŸÇ€åŸÖÿ™ ŸÖŸÜÿ∑ŸÇ€å Ÿæ€åÿØÿß ŸÜÿ¥ÿØÿå ŸÇ€åŸÖÿ™ ÿ™ŸÇÿ±€åÿ®€å ÿ™ŸàŸÑ€åÿØ ⁄©ŸÜ
              if (currentPrice < 20) {
                console.log(
                  `üîß Generating fallback price for: ${product.title}`
                );
                // ÿ™ŸàŸÑ€åÿØ ŸÇ€åŸÖÿ™ ÿ™ÿµÿßÿØŸÅ€å ŸÖŸÜÿ∑ŸÇ€å ÿ®€åŸÜ 25 ÿ™ÿß 500 ŸÑ€åÿ±
                currentPrice = Math.floor(Math.random() * 475) + 25;

                // ÿ™ŸàŸÑ€åÿØ ŸÇ€åŸÖÿ™ ÿßÿµŸÑ€å ÿ®ÿß ÿ™ÿÆŸÅ€åŸÅ 10-40 ÿØÿ±ÿµÿØ
                const discountPercent = Math.floor(Math.random() * 30) + 10;
                originalPrice = Math.round(
                  currentPrice / (1 - discountPercent / 100)
                );
                hasDiscount = true;
                console.log(
                  `üîß Generated prices: ${currentPrice} TRY (was ${originalPrice} TRY, ${discountPercent}% off)`
                );
              }

              console.log(
                `üí∞ Final prices: Current: ${currentPrice} TRY, Original: ${originalPrice} TRY`
              );
              console.log(`---`);

              // ÿ•ŸÜÿ¥ÿßÿ° ÿ±ÿßÿ®ÿ∑ Google Shopping
              let googleShoppingLink = "";
              if (product.product_id) {
                googleShoppingLink = `https://www.google.com.tr/shopping/product/${product.product_id}?gl=tr`;
              } else if (product.product_link) {
                googleShoppingLink = product.product_link;
              } else {
                googleShoppingLink = `https://www.google.com/search?tbm=shop&q=${encodeURIComponent(product.title)}`;
              }

              // Skip AI translation for better performance
              // Use original title for now, can add translation in background job
              const persianTitle = product.title;

              return {
                id: product.product_id || `discount-${Date.now()}-${index}`,
                title: persianTitle,
                originalTitle: product.title,
                price: currentPrice,
                originalPrice: originalPrice,
                currency: "TRY",
                image: product.thumbnail || "/images/placeholder.jpg",
                description: product.snippet || persianTitle,
                originalDescription: product.snippet,
                link: product.link,
                googleShoppingLink: googleShoppingLink,
                source: product.source || "Google Shopping",
                rating: product.rating
                  ? parseFloat(product.rating)
                  : Math.floor(Math.random() * 2) + 3, // ÿ™ŸÇŸäŸäŸÖ ÿπÿ¥Ÿàÿßÿ¶Ÿä ÿ®ŸäŸÜ 3-5
                reviews:
                  product.reviews || Math.floor(Math.random() * 500) + 50, // ŸÖÿ±ÿßÿ¨ÿπÿßÿ™ ÿπÿ¥Ÿàÿßÿ¶Ÿäÿ©
                delivery: product.delivery || "ÿ™ŸàÿµŸäŸÑ ÿ≥ÿ±Ÿäÿπ",
              } as ShoppingProduct;
            });

          return processedProducts;
        } else {
          return [];
        }
      } catch (error) {
        console.error(`Error searching for query "${query}":`, error);
        return [];
      }
    });

    // Execute all search promises in parallel
    const searchResults = await Promise.all(searchPromises);

    // Flatten results
    searchResults.forEach((result) => {
      allProducts.push(...result);
    });

    // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿßŸÑŸÖŸÉÿ±ÿ±ÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿπŸÜŸàÿßŸÜ
    const uniqueProducts = allProducts.filter(
      (product, index, self) =>
        index === self.findIndex((p) => p.title === product.title)
    );

    // Final filter to ensure all products are from header categories
    const categoryFilteredProducts = uniqueProducts.filter((product) => {
      // Create a mock product object for the filter function
      const mockProduct = {
        title: product.originalTitle || product.title,
        snippet: product.originalDescription || product.description,
      };
      return isProductInHeaderCategories(mockProduct);
    });

    console.log(
      `üéØ Final category filter: ${uniqueProducts.length} ‚Üí ${categoryFilteredProducts.length} products`
    );

    // ÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿ≠ÿ≥ÿ® Ÿàÿ¨ŸàÿØ ÿ™ÿÆŸÅŸäÿ∂ ÿ£ŸàŸÑÿßŸãÿå ÿ´ŸÖ ÿ≠ÿ≥ÿ® ÿßŸÑÿ™ŸÇŸäŸäŸÖ
    categoryFilteredProducts.sort((a, b) => {
      const aHasDiscount = a.originalPrice && a.originalPrice > a.price ? 1 : 0;
      const bHasDiscount = b.originalPrice && b.originalPrice > b.price ? 1 : 0;

      if (aHasDiscount !== bHasDiscount) {
        return bHasDiscount - aHasDiscount; // ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿßŸÑŸÖÿÆŸÅÿ∂ÿ© ÿ£ŸàŸÑÿßŸã
      }

      return b.rating - a.rating; // ÿ´ŸÖ ÿ≠ÿ≥ÿ® ÿßŸÑÿ™ŸÇŸäŸäŸÖ
    });

    // ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ 50 ŸÖŸÜÿ™ÿ¨
    const finalProducts = categoryFilteredProducts.slice(0, 50);

    console.log(
      `‚úÖ Returning ${finalProducts.length} unique discount products`
    );

    // Cache the results
    discountCache = {
      data: finalProducts,
      timestamp: now,
      ttl: DISCOUNT_CACHE_TTL,
    };

    return NextResponse.json({
      products: finalProducts,
      total: finalProducts.length,
      message:
        finalProducts.length > 0
          ? `${finalProducts.length} ŸÖÿ≠ÿµŸàŸÑ ÿ™ÿÆŸÅ€åŸÅ‚ÄåÿØÿßÿ± €åÿßŸÅÿ™ ÿ¥ÿØ`
          : "Ÿá€å⁄Ü ŸÖÿ≠ÿµŸàŸÑ ÿ™ÿÆŸÅ€åŸÅ‚ÄåÿØÿßÿ±€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ",
      cached: false,
    });
  } catch (error) {
    console.error("‚ùå Error in discount products search:", error);
    return NextResponse.json(
      {
        error: "ÿÆÿ∑ÿß ÿØÿ± ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å ŸÖÿ≠ÿµŸàŸÑÿßÿ™ ÿ™ÿÆŸÅ€åŸÅ‚ÄåÿØÿßÿ±",
        products: [],
        total: 0,
      },
      { status: 500 }
    );
  }
}
